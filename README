#============
# Exact match
#============
# Should hit
curl 'localhost:9200/artist/_search' -d '{"query": {"text": { "title" : {"operator": "or", "query": "the high level Ranters", "type": "phrase" }}}}}}'

# Should miss
curl 'localhost:9200/artist/_search' -d '{"query": {"text": { "title" : {"operator": "or", "query" : "the high lev", "type": "phrase" }}}}}}'



#==============
# Phrase prefix (not using ngrams yet)
#==============

# Should hit
curl 'localhost:9200/artist/_search' -d '{"query": {"text": { "title" : {"operator": "or", "query": "the high lev", "type": "phrase_prefix" }}}}}}'

# Should also hit
curl 'localhost:9200/artist/_search' -d '{"query": {"text": { "title" : {"operator": "or", "query" : "the high level Ranters", "type": "phrase_prefix" }}}}}}'


#=============
# Autocomplete (using ngrams and a boolean query)
#
# title := (title.title) the exact match field
# title.partial := ngrammed
#
# The boolean query sums the hits, so either an exact or a partial will return, 
# however an exact match will hit on both fields and score higher.
#=============

curl 'localhost:9200/artist/_search' -d '
	{ "query": 
		{ "bool": 
			{ "should": [ 
				{ "text": { "title": "The High" } },
				{ "text": { "title.partial": "The High" } }
	]}}}'


##
## Ngrams approach requires defining a custom analyser at index-time.  I haven't found a query-time way to do this yet.
##
